<feed xmlns="http://www.w3.org/2005/Atom"> <id>https://www.galados.com/</id><title>Aperture Science</title><subtitle>A minimal, portfolio, sidebar, bootstrap Jekyll theme with responsive web design and focuses on text presentation.</subtitle> <updated>2023-04-14T10:50:00+08:00</updated> <author> <name>GalaDOS</name> <uri>https://www.galados.com/</uri> </author><link rel="self" type="application/atom+xml" href="https://www.galados.com/feed.xml"/><link rel="alternate" type="text/html" hreflang="en" href="https://www.galados.com/"/> <generator uri="https://jekyllrb.com/" version="4.3.2">Jekyll</generator> <rights> © 2023 GalaDOS </rights> <icon>/assets/img/favicons/favicon.ico</icon> <logo>/assets/img/favicons/favicon-96x96.png</logo> <entry><title>视频Jitter Buffer原理</title><link href="https://www.galados.com/posts/Video-Jitter-Buffer/" rel="alternate" type="text/html" title="视频Jitter Buffer原理" /><published>2023-04-07T16:02:00+08:00</published> <updated>2023-04-14T10:49:21+08:00</updated> <id>https://www.galados.com/posts/Video-Jitter-Buffer/</id> <content src="https://www.galados.com/posts/Video-Jitter-Buffer/" /> <author> <name>GalaDOS</name> </author> <category term="public" /> <summary> 本文以WebRTC中的FrameBuffer为例，介绍了基于卡尔曼滤波的Jitter Buffer的原理。 前言 由于网络带宽以及视频码率都不是恒定的，当视频数据在网络传输时，各帧数据实际上并不是按照帧率匀速到达的，即存在抖动（Jitter）。为了保证在线播放视频时帧率稳定，不出现快慢放，客户端往往会在本地缓存一段数据，再按照帧率读取渲染。这个机制我们可以称之为Jitter Buffer。显然的，允许缓存的数据越多，视频卡顿的概率越低。在点播场景下，我们可以简单地设置一个较大的Buffer来换取播放的流畅性。但对于实时音视频通话等时延敏感应用来说，增大缓存意味着增加时延，会极大地降低用户体验。所以如何决策出合适的Buffer大小就成为了一个需要优化的内容。注意本文中衡量Jitter Buffer大小的单位都使用时间，而非字节数，这样便于表达。 Jitter Buffer多大最合适... </summary> </entry> <entry><title>GCC带宽探测原理</title><link href="https://www.galados.com/posts/GCC-Bandwidth-Detection/" rel="alternate" type="text/html" title="GCC带宽探测原理" /><published>2022-01-18T20:16:00+08:00</published> <updated>2023-04-14T10:49:21+08:00</updated> <id>https://www.galados.com/posts/GCC-Bandwidth-Detection/</id> <content src="https://www.galados.com/posts/GCC-Bandwidth-Detection/" /> <author> <name>GalaDOS</name> </author> <category term="public" /> <summary> 前言 拥塞控制是RTC系统中非常重要的一个功能模块，直接关系到通信质量。而在谷歌开源的WebRTC中，就有着名为GCC（Google Congestion Control）的优秀实现供我们参考学习。但是由于其代码经历大量迭代，兼容和实验性质的代码较多，不利于阅读。本文将结合流程图分析GCC的带宽探测过程。使用的WebRTC版本为72，分析内容不包含默认不开启的实验代码和废弃代码。阅读本文需要对RTP协议有一定了解。 TransportSequenceNumber 与 TransportCC 根据协商结果的不同，WebRTC会采用不同的方式评估带宽。当上层协商启用RTP拓展AbsSendTime以及RTCP类型REMB时，带宽的计算工作主要集中在接收端；而当启用RTP拓展TransportSequenceNumber以及RTCP类型TransportCC时，计算工作则几乎全在发送端。... </summary> </entry> <entry><title>视频码率控制原理</title><link href="https://www.galados.com/posts/Video-Rate-Control/" rel="alternate" type="text/html" title="视频码率控制原理" /><published>2021-11-17T20:16:00+08:00</published> <updated>2023-04-14T10:49:21+08:00</updated> <id>https://www.galados.com/posts/Video-Rate-Control/</id> <content src="https://www.galados.com/posts/Video-Rate-Control/" /> <author> <name>GalaDOS</name> </author> <category term="public" /> <summary> 本文简要总结了笔者对视频编码技术中码率控制算法的理解。例子的范围限制在从H.264至今的编码标准，更早的编码标准笔者并没有了解过。 名词解释 视频编码（video encoding）：将视频的原始像素数据压缩为符合某些标准（比如H.264）的二进制数据的过程。 码率（bitrate）：单位时间内的数据量，一般用bps（bits per second）作为单位。 MB：宏块（macro block），实际上在不同的编码标准中它有不同的叫法，但本文使用H.264/AVC中的MB。它是视频编码的基本单元，常见的大小有16x16、64x64等。编码时每一帧画面都会被按照固定大小分割成大量MB，再一个个处理。 QP：量化参数（quantization parameter）。视频压缩一般为有损压缩，编码时需要为每一帧以及每一个MB选择QP，用以控制画面质量与码率。QP越大，则... </summary> </entry> <entry><title>视频隐形水印技术分类</title><link href="https://www.galados.com/posts/Video-Stego/" rel="alternate" type="text/html" title="视频隐形水印技术分类" /><published>2021-09-30T09:30:00+08:00</published> <updated>2023-04-14T10:49:21+08:00</updated> <id>https://www.galados.com/posts/Video-Stego/</id> <content src="https://www.galados.com/posts/Video-Stego/" /> <author> <name>GalaDOS</name> </author> <category term="public" /> <summary> 说明：本文是笔者之前给公司公众号写的两篇隐形水印科普文章的整合与扩充，介绍了能够在视频数据中嵌入隐形数据的技术。 前言 起初笔者只是被论坛里一个讨论隐写术的帖子引起了兴趣，期望找到一种隐藏的信息经过转码甚至屏摄后依然不会丢失的视频隐写技术，即一种可靠的隐形数字水印技术。遗憾的是一番资料查下来，发现现有的技术和笔者的期望依然存在一定距离。但查都查了，这里还是分类总结一下。 封装级水印 首先是实现最简单的封装级水印。视频封装即视频容器层的数据，通俗地理解就是文件格式。这里贴张图科普一下视频文件的基本构成。 视频文件的基本结构 因为这一层数据是和外界直接交互的，所以只要熟悉格式标准就能通过改写二进制数据来嵌入数据。曾经流行的图种就是一种最简单的图像封装层的隐写。也许有些人不知道图种是什么。简单地说，如果你从网络上下载了一张jpeg图片，用解压软件对它进行解压，能得到其他文件，比如... </summary> </entry> </feed>
